-- Visual Variables
local espColor = Color3.fromRGB(255, 0, 0)
local fovColor = Color3.fromRGB(255, 255, 255)
local workspaceESP = {}
local espBoxes = {}
local chamsParts = {}
local originalProperties = {}
local originalLightingSettings = {
    Brightness = game.Lighting.Brightness,
    OutdoorAmbient = game.Lighting.OutdoorAmbient,
    Ambient = game.Lighting.Ambient,
    GlobalShadows = game.Lighting.GlobalShadows,
    FogEnd = game.Lighting.FogEnd,
    FogStart = game.Lighting.FogStart
}
local transparencyValue = 0.9
local xrayEnabled = false
local keybindKey = Enum.KeyCode.X
local folder = workspace:FindFirstChild("BuiltObjects")
local excludedModels = {
    "Large Storage Box", "Furnace", "Campfire", "Repair Bench", "Small Storage Box"
}
local hitboxSize = 0
local hitboxTransparency = 0
local TPWalkSpeed = 0
local originalModelTransparency = {}


-- FOV settings
local fovAmount = 120
local teamCheck = false
local targetPart = "Head"  -- Default target is Head
local maxRenderDistance = 1000 -- Adjustable global max render distance

-- FOV Circle
local fovCircle = Drawing.new("Circle")
fovCircle.Radius = fovAmount
fovCircle.Visible = true
fovCircle.Color = Color3.fromRGB(247, 126, 192)
fovCircle.Thickness = 1
fovCircle.NumSides = 11
fovCircle.Position = Vector2.new(0, 0)

-- Toggle states
local isAimbotEnabled = false
local chamsEnabled = false
local rightMouseHeld = false
local isFOVVisible = true
local isVisibilityCheckEnabled = false
local showNames = false
local espEnabled = false
local isFullbrightEnabled = false
local isHitboxExpander = false
local expanderConnection = nil
local showWeapon = false
local isTpWalking = false
local tpwalking = false
local tpwalking_connection = nil
local distanceEnabled = false

--Aimbot Settings
local smoothness = 1 -- Default smoothness value
local aimbotKey = Enum.KeyCode.F

local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'

local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

-- Services
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer


-- Create window
local Window = Library:CreateWindow({
    Title = 'Auralis | Beta Version',
    Center = true, 
    AutoShow = true,
})

-- Create Tabs
local Tabs = {
    Main = Window:AddTab('Main'), 
    ESP = Window:AddTab('ESP'),
    WeaponsTab = Window:AddTab('Weapons'),
    ['World'] = Window:AddTab('World'),
    ['Misc'] = Window:AddTab('Misc'),
    ['UI Settings'] = Window:AddTab('Settings'),
}

-- Main Tab
local MainLeftBox = Tabs.Main:AddLeftGroupbox('Aimbot')
local MainRightBox = Tabs.Main:AddRightGroupbox('FOV Settings')
local MainCrosshairBox = Tabs.Main:AddRightGroupbox('Crosshair')
local MainHitboxBox = Tabs.Main:AddLeftGroupbox("Hitbox Expander")
local ESPLeftBox = Tabs.ESP:AddLeftGroupbox('ESP Settings')
local WeaponsLeftBox = Tabs.WeaponsTab:AddLeftGroupbox("Fast Reload")
local WorldLeftBox = Tabs.World:AddLeftGroupbox('World Settings')
local MiscLeftBox = Tabs.Misc:AddLeftGroupbox('Miscellaneous')
local MovementBox = Tabs.Misc:AddRightGroupbox('Another Miscellaneous')
local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')
local ThirdPersonBox = Tabs.Misc:AddRightGroupbox('Third Person')
local NoclipBox = Tabs.Misc:AddRightGroupbox('Noclip')

-- Initialize Drawing objects after UI
local success, Drawing = pcall(function() return Drawing end)
if not success then
    warn("Drawing API not available")
    return
end

local crosshair = {
    horizontal = Drawing.new("Line"),
    vertical = Drawing.new("Line")
}

-- Update workspace ESP functions
local function createWorkspaceESP(model)
    local head = model:FindFirstChild("Head", true)
    if not head or not head:IsA("MeshPart") then return end
    
    local esp = {
        text = Drawing.new("Text"),
        highlight = Instance.new("Highlight")
    }
    
    esp.text.Size = 16
    esp.text.Center = true
    esp.text.Outline = true
    esp.text.Visible = false
    esp.text.Color = espColor
    
    esp.highlight.FillColor = espColor
    esp.highlight.OutlineColor = Color3.new(1, 1, 1)
    esp.highlight.FillTransparency = 0.5
    esp.highlight.OutlineTransparency = 0
    esp.highlight.Enabled = false
    esp.highlight.Adornee = head
    esp.highlight.Parent = game:GetService("CoreGui")
    
    workspaceESP[model] = esp
    return esp
end

RunService.RenderStepped:Connect(function()
    if not espEnabled then
        for _, esp in pairs(workspaceESP) do
            esp.text.Visible = false
            esp.highlight.Enabled = false
        end
        return
    end

    local camera = workspace.CurrentCamera
    local localPlayer = Players.LocalPlayer
    local character = localPlayer.Character
    local rootPart = character and character:FindFirstChild("HumanoidRootPart")
    local playersFolder = workspace:FindFirstChild("Players")

    if not rootPart or not playersFolder then return end

    for _, model in pairs(playersFolder:GetChildren()) do
        if model.Name == localPlayer.Name then continue end

        if not workspaceESP[model] then
            workspaceESP[model] = createWorkspaceESP(model)
        end

        local esp = workspaceESP[model]
        local head = model:FindFirstChild("Head", true)

        if esp and head and head:IsA("MeshPart") then
            local pos = head.Position
            local screenPos, onScreen = camera:WorldToViewportPoint(pos)
            local distance = (rootPart.Position - pos).Magnitude

            if distance <= maxRenderDistance and onScreen then
            local nameLine = showNames and model.Name or ""
            local heldTool = ""
            local distanceLine = distanceEnabled and string.format("[%d studs]", math.floor(distance)) or ""

            if showWeapon then
                local player = Players:FindFirstChild(model.Name)
                if player then
                    local character = player.Character
                    if character then
                        for _, tool in ipairs(character:GetChildren()) do
                            if tool:IsA("Tool") then
                                heldTool = tool.Name
                                break
                            end
                        end
                    end
                    
                    if heldTool == "" and player:FindFirstChild("Backpack") then
                        for _, tool in ipairs(player.Backpack:GetChildren()) do
                            if tool:IsA("Tool") then
                                heldTool = tool.Name
                                break
                            end
                        end
                    end
                    
                    if heldTool == "" then
                        heldTool = "[Empty]"
                    end
                end
            end
            local textLines = {}

            if nameLine ~= "" then table.insert(textLines, nameLine) end
            if heldTool ~= "" then table.insert(textLines, heldTool) end
            if distanceLine ~= "" then table.insert(textLines, distanceLine) end

            -- Adjust position to shift name higher and distance lower
            local lineCount = #textLines
            local offset = -20 * lineCount  -- moves the entire block up slightly
            esp.text.Position = Vector2.new(screenPos.X, screenPos.Y + offset)

            esp.text.Text = table.concat(textLines, "\n")
            esp.text.Visible = #textLines > 0
                                        

                esp.highlight.Enabled = chamsEnabled
            else
                esp.text.Visible = false
                esp.highlight.Enabled = false
            end
        end
    end

    for model, esp in pairs(workspaceESP) do
        if not model:IsDescendantOf(playersFolder) then
            if esp.text then esp.text:Remove() end
            if esp.highlight then esp.highlight:Destroy() end
            workspaceESP[model] = nil
        end
    end
end)


-- Add death handling functions
local function removeEspBox(player)
    if espBoxes[player] then
        pcall(function()
            espBoxes[player].outline:Remove()
            espBoxes[player].text:Remove()
            espBoxes[player] = nil
        end)
    end
end

local function setupDeathHandler(player)
    if player.Character then
        local humanoid = player.Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.Died:Connect(function()
                removeEspBox(player)
            end)
        end
    end
end

-- Add character handlers after ESP creation
game.Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        setupDeathHandler(player)
    end)
end)

game.Players.PlayerRemoving:Connect(function(player)
    removeEspBox(player)
end)

-- Setup existing players
for _, player in pairs(game.Players:GetPlayers()) do
    if player ~= game.Players.LocalPlayer then
        setupDeathHandler(player)
        player.CharacterAdded:Connect(function(character)
            setupDeathHandler(player)
        end)
    end
end

-- Add Chams function
local function applyChams(player)
    if not player.Character then return end
    if teamCheck and player.Team == game.Players.LocalPlayer.Team then return end
    
    for _, part in pairs(player.Character:GetDescendants()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            if not originalProperties[part] then
                originalProperties[part] = {
                    Material = part.Material,
                    Color = part.Color,
                    Transparency = part.Transparency
                }
            end
            
            part.Material = Enum.Material.ForceField
            part.Color = espColor
            part.Transparency = 0.6
            table.insert(chamsParts, part)
        end
    end
end

RunService.RenderStepped:Connect(function()
    if not chamsEnabled then return end

    local localCharacter = Players.LocalPlayer.Character
    local localRoot = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart")
    if not localRoot then return end

    for _, player in ipairs(Players:GetPlayers()) do
        if player == Players.LocalPlayer then continue end
        local character = player.Character
        if not character or not character:FindFirstChild("HumanoidRootPart") then continue end

        -- Team check
        if teamCheck and player.Team == Players.LocalPlayer.Team then continue end

        local distance = (localRoot.Position - character.HumanoidRootPart.Position).Magnitude
        if distance > maxRenderDistance then continue end

        -- Apply Chams to character parts
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                -- Save original properties only once
                if not originalProperties[part] then
                    originalProperties[part] = {
                        Material = part.Material,
                        Color = part.Color,
                        Transparency = part.Transparency
                    }
                end

                -- Apply chams color/material once
                if not table.find(chamsParts, part) then
                    part.Material = Enum.Material.ForceField
                    part.Color = espColor
                    part.Transparency = 0.6
                    table.insert(chamsParts, part)
                end
            end
        end
    end
end)

local function isExcluded(modelName)
    for _, excludedName in ipairs(excludedModels) do
        if modelName == excludedName then
            return true
        end
    end
    return false
end

local function setTransparency(model, transparency)
    for _, descendant in ipairs(model:GetDescendants()) do
        if descendant:IsA("BasePart") or descendant:IsA("MeshPart") or descendant:IsA("Part") then
            if transparency ~= nil then
                -- Save original transparency once
                if not originalModelTransparency[descendant] then
                    originalModelTransparency[descendant] = descendant.Transparency
                end
                descendant.Transparency = transparency
            else
                -- Restore
                if originalModelTransparency[descendant] then
                    descendant.Transparency = originalModelTransparency[descendant]
                    originalModelTransparency[descendant] = nil
                end
            end
        end
    end
end

local function updateXray()
    if not folder then
        warn("Folder not found in workspace.")
        return
    end

    for _, model in ipairs(folder:GetChildren()) do
        if model:IsA("Model") and not isExcluded(model.Name) then
            if xrayEnabled then
                setTransparency(model, transparencyValue)
            else
                -- Restore original transparencies
                setTransparency(model, nil) -- nil will trigger restoration
            end
        end
    end
end

MainLeftBox:AddToggle('AimbotEnabled', {
    Text = 'Enable Aimbot',
    Default = false,
    Tooltip = 'Toggle Aimbot functionality',
    Callback = function(value) isAimbotEnabled = value end
})

MainLeftBox:AddToggle('VisibilityCheck', {
    Text = 'Wall Check',
    Default = false,
    Tooltip = 'Check if target is visible before aiming',
    Callback = function(value) isVisibilityCheckEnabled = value end
})

MainLeftBox:AddDropdown('TargetPartDropdown', {
    Values = { 'Head', 'UpperTorso', 'HumanoidRootPart' },
    Default = 1,
    Multi = false,
    Text = 'Target Part',
    Tooltip = 'Choose which body part to aim at',
    Callback = function(value)
        targetPart = value
        Library:Notify('Now aiming at: ' .. targetPart, 2)
    end
})

MainRightBox:AddSlider('FOVAmount', {
    Text = 'FOV Size',
    Default = 120,
    Min = 20,
    Max = 1000,
    Rounding = 1,
    Compact = false,
    Callback = function(value)
        fovAmount = value
        fovCircle.Radius = value
    end
})

MainRightBox:AddSlider('Smoothness', {
    Text = 'Aim Smoothness',
    Default = 1,
    Min = 0.1,
    Max = 1,
    Rounding = 1,
    Compact = false,
    Callback = function(value) smoothness = value end
})

MainRightBox:AddToggle('ShowFOV', {
    Text = 'Show FOV',
    Default = true,
    Tooltip = 'Toggle FOV circle visibility',
    Callback = function(value)
        isFOVVisible = value
        fovCircle.Visible = value
    end
})

MainRightBox:AddLabel('FOV Color'):AddColorPicker('FOVColor', {
    Default = Color3.fromRGB(247, 126, 192),
    Title = 'FOV Circle Color',
    Callback = function(value)
        fovCircle.Color = value
    end
})

MainHitboxBox:AddToggle('HitboxExpander', {
    Text = 'Hitbox Expander',
    Default = false,
    Tooltip = 'Expands enemy and helicopter hitboxes',
    Callback = function(value)
        isHitboxExpander = value

        if expanderConnection then
            expanderConnection:Disconnect()
            expanderConnection = nil
            for _, player in ipairs(workspace.Players:GetChildren()) do
                if player ~= Players.LocalPlayer.Character then
                    local head = player:FindFirstChild("Head")
                    if head then
                        head.Size = Vector3.new(1, 1, 1)
                        head.Transparency = 0
                    end
                end
            end
            local heli = workspace:FindFirstChild("ActiveRaiderX")
            if heli and heli:FindFirstChild("Base") then
                heli.Base.Size = Vector3.new(1, 1, 1)
                heli.Base.Transparency = 0
            end
        end

        if value then
            expanderConnection = RunService.Heartbeat:Connect(function()
                for _, player in ipairs(workspace.Players:GetChildren()) do
                    if player ~= Players.LocalPlayer.Character then
                        local head = player:FindFirstChild("Head")
                        if head then
                            head.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
                            head.Transparency = hitboxTransparency
                            head.Massless = true
                            head.CanCollide = false
                        end
                    end
                end
                local heli = workspace:FindFirstChild("ActiveRaiderX")
                if heli and heli:FindFirstChild("Base") then
                    heli.Base.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
                    heli.Base.Transparency = hitboxTransparency
                    heli.Base.Massless = true
                    heli.Base.CanCollide = false
                end
            end)
        end
    end
})

MainHitboxBox:AddSlider('HitboxSize', {
    Text = 'Hitbox Size',
    Default = 15,
    Min = 0,
    Max = 50,
    Rounding = 1,
    Compact = false,
    Tooltip = 'Adjust hitbox size',
    Callback = function(value)
        hitboxSize = value
    end
})

MainHitboxBox:AddSlider('HitboxTransparency', {
    Text = 'Hitbox Transparency',
    Default = 0.9,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Compact = false,
    Tooltip = 'Adjust hitbox transparency',
    Callback = function(value)
        hitboxTransparency = value
    end
})

-- Aimbot | FOV | Toggle Part | Stuff Above --

ESPLeftBox:AddToggle('ESP Toggle', {
    Text = 'ESP Toggle',
    Tooltip = 'Turn on or off ESP',
    Callback = function(state)
        espEnabled = state
        if not state then
            for _, esp in pairs(workspaceESP) do
                esp.text.Visible = false
                esp.highlight.Enabled = false
            end
        end
    end
})

ESPLeftBox:AddLabel('ESP Color'):AddColorPicker('ESP Color', {
    Text = 'ESP Color',
    Tooltip = 'Change ESP color',
    Default = Color3.fromRGB(255, 0, 0),
    Callback = function(color)
        espColor = color
        for _, esp in pairs(workspaceESP) do
            esp.text.Color = color
            esp.highlight.FillColor = color
        end
    end
})

ESPLeftBox:AddToggle('Team Check', {
    Text = 'Team Check',
    Tooltip = 'Toggle team check for visuals',
    Callback = function(state)
        teamCheck = state
    end
})

-- Add Chams toggle to Visuals tab
ESPLeftBox:AddToggle('Chams', { 
    Text = 'Chams',
    Tooltip = 'See players through walls',
    Callback = function(state)
        chamsEnabled = state
        if not state then
            for part, props in pairs(originalProperties) do
                if part and part:IsA("BasePart") then
                    part.Material = props.Material
                    part.Color = props.Color
                    part.Transparency = props.Transparency
                end
            end
            table.clear(chamsParts)
            table.clear(originalProperties)
        end
    end
})

ESPLeftBox:AddToggle('Show Names', {
    Text = 'Show Player Names',
    Tooltip = 'Only works when ESP is also enabled',
    Callback = function(state)
        showNames = state
        if not (espEnabled and showNames) then
            for _, esp in pairs(workspaceESP) do
                if esp.text then
                    esp.text.Visible = false
                end
            end
        end
    end
})

-- Add workspace ESP toggle
ESPLeftBox:AddToggle('Distance ESP', {
    Text = 'Distance ESP',
    Tooltip = 'Show distance to workspace players', 
    Callback = function(state)
        distanceEnabled = state
        if not state then
            for _, esp in pairs(workspaceESP) do
                esp.text.Visible = false
                esp.highlight.Enabled = false
            end
        end
    end
})

-- | All ESP Settings And Toggles Above | --

WorldLeftBox:AddToggle('Fullbright', {
    Text = 'Fullbright',
    Default = false,
    Callback = function(value)
        isFullbrightEnabled = value
        
        if isFullbrightEnabled then
            game.Lighting.Brightness = 2
            game.Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
            game.Lighting.Ambient = Color3.fromRGB(255, 255, 255)
            game.Lighting.GlobalShadows = false
        else
            game.Lighting.Brightness = originalLightingSettings.Brightness
            game.Lighting.OutdoorAmbient = originalLightingSettings.OutdoorAmbient
            game.Lighting.Ambient = originalLightingSettings.Ambient
            game.Lighting.GlobalShadows = originalLightingSettings.GlobalShadows
        end
    end
})

WorldLeftBox:AddToggle('NoFog', {
    Text = 'No Fog',
    Default = false,
    Tooltip = 'Removes fog by pushing it far away',
    Callback = function(enabled)
        if enabled then
            game.Lighting.FogStart = 0
            game.Lighting.FogEnd = 1e10
            Library:Notify('Fog removed', 2)
        else
            game.Lighting.FogStart = originalLightingSettings.FogStart
            game.Lighting.FogEnd = originalLightingSettings.FogEnd
            Library:Notify('Fog restored', 2)
        end
    end
})

-- | All World Settings And Toggles Above | --

MiscLeftBox:AddToggle('XRay', {
    Text = 'XRay',
    Default = false,
    Callback = function(value)
        xrayEnabled = value
        updateXray()
    end
})

MiscLeftBox:AddSlider('XRayTransparency', {
    Text = 'XRay Transparency',
    Default = 0.9,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Compact = false,
    Callback = function(value)
        transparencyValue = value
        if xrayEnabled then updateXray() end
    end
})

MiscLeftBox:AddInput('XRayBind', {
    Default = 'X',
    Numeric = false,
    Text = 'XRay Keybind',
    Tooltip = 'Press a key to bind',
    Placeholder = 'Key',
    Callback = function(value)
        keybindKey = Enum.KeyCode[value:upper()]
    end
})

MovementBox:AddToggle('TPWalk', {
    Text = 'Speedhack',
    Default = false,
    Tooltip = 'Makes you run faster [BLATANT]',
    Callback = function(value)
        isTpWalking = value
        tpwalking = value
        if value then
            local chr = LocalPlayer.Character
            local hum = chr and chr:FindFirstChildWhichIsA("Humanoid")

            if hum then
                local function tpwalk()
                    if tpwalking and chr and hum and hum.Parent then
                        if hum.MoveDirection.Magnitude > 0 then
                            chr:TranslateBy(hum.MoveDirection * TPWalkSpeed / 100)
                        end
                    end
                end

                local tpwalking_connection = RunService.Heartbeat:Connect(function()
                    pcall(function()
                        if not isTpWalking then
                            tpwalking_connection:Disconnect()
                            return
                        end
                        tpwalk()
                    end)
                end)
            end
        end
    end
})

MovementBox:AddSlider('TPWalkSpeed', {
    Text = 'Speedhack Speed',
    Default = 0,
    Min = 0,
    Max = 25,
    Rounding = 0,
    Compact = false,
    Callback = function(value)
        TPWalkSpeed = value
    end
})

-- | All Misc Settings And Toggles Above | --

UserInputService.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        rightMouseHeld = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        rightMouseHeld = false
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if input.KeyCode == keybindKey and not gameProcessed then
        xrayEnabled = not xrayEnabled
        updateXray()
        Library:Notify('Xray ' .. (xrayEnabled and "Enabled" or "Disabled"), 2)
    end
end)

RunService.RenderStepped:Connect(function()
    if isFOVVisible then
        local mouseLocation = UserInputService:GetMouseLocation()
        fovCircle.Position = Vector2.new(mouseLocation.X, mouseLocation.Y)
    end
end)

local function IsInFov(position)
    local mouse = UserInputService:GetMouseLocation()
    local screenPosition, onScreen = Camera:WorldToViewportPoint(position)
    local distance = (Vector2.new(screenPosition.X, screenPosition.Y) - mouse).Magnitude
    return onScreen and distance <= fovAmount
end

local function IsVisible(targetPart)
    local origin = Camera.CFrame.Position
    local direction = (targetPart.Position - origin).Unit
    local distance = (targetPart.Position - origin).Magnitude

    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    rayParams.FilterDescendantsInstances = {
        game.Players.LocalPlayer.Character,
        targetPart.Parent
    }
    rayParams.IgnoreWater = true

    local result = workspace:Raycast(origin, direction * distance, rayParams)
    return not result or (result.Position - targetPart.Position).Magnitude < 3
end

local function GetClosestPlayer()
    local closest, closestDistance = nil, math.huge
    local mouse = UserInputService:GetMouseLocation()

    local playersFolder = workspace:FindFirstChild("Players")
    if not playersFolder then return nil end

    for _, model in pairs(playersFolder:GetChildren()) do
        if model.Name ~= Players.LocalPlayer.Name then
            local target = model:FindFirstChild(targetPart, true)
            local humanoid = model:FindFirstChild("Humanoid")

            if target and humanoid and humanoid.Health > 0 and IsInFov(target.Position) then
                if teamCheck then
                    local plr = Players:FindFirstChild(model.Name)
                    local localTeam = Players.LocalPlayer.Team
                
                    if plr and localTeam and plr.Team == localTeam then
                        continue
                    end
                end                

                local screenPos, onScreen = Camera:WorldToViewportPoint(target.Position)
                if onScreen then
                    local dist = (Vector2.new(screenPos.X, screenPos.Y) - mouse).Magnitude
                    if dist < closestDistance then
                        if not isVisibilityCheckEnabled or IsVisible(target) then
                            closest = target
                            closestDistance = dist
                        end
                    end
                end
            end
        end
    end

    return closest
end

RunService.RenderStepped:Connect(function()
    -- Early exit unless both aimbot is toggled AND right-click is held
    if not isAimbotEnabled or not rightMouseHeld then return end

    local target = GetClosestPlayer()
    if target then
        local camPos = Camera.CFrame.Position
        local targetPos = target.Position
        local newCFrame = CFrame.new(camPos, targetPos)

        Camera.CFrame = Camera.CFrame:Lerp(newCFrame, smoothness)
    end
end)
