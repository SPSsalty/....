local espColor = Color3.fromRGB(255, 0, 0)
local fovColor = Color3.fromRGB(255, 255, 255)
local workspaceESP = {}
local espBoxes = {}
local chamsParts = {}
local originalProperties = {}
local originalLightingSettings = {
    Brightness = game.Lighting.Brightness,
    OutdoorAmbient = game.Lighting.OutdoorAmbient,
    Ambient = game.Lighting.Ambient,
    GlobalShadows = game.Lighting.GlobalShadows,
    FogEnd = game.Lighting.FogEnd,
    FogStart = game.Lighting.FogStart
}
local transparencyValue = 0.9
local xrayEnabled = false
local keybindKey = Enum.KeyCode.X
local folder = workspace:FindFirstChild("BuiltObjects")
local excludedModels = {
    "Large Storage Box", "Furnace", "Campfire", "Repair Bench", "Small Storage Box"
}
local hitboxSize = 0
local hitboxTransparency = 0
local TPWalkSpeed = 0
local originalModelTransparency = {}
local sleepingESP = {}
local oreESP = {}
local resourcesFolder = workspace:FindFirstChild("Resources")
local clothFolder = workspace:FindFirstChild("ClothPlants")
local backpackESP = {}

local fovAmount = 120
local teamCheck = false
local targetPart = "Head" 
local espRenderDistance = 1000

local fovCircle = Drawing.new("Circle")
fovCircle.Radius = fovAmount
fovCircle.Visible = true
fovCircle.Color = Color3.fromRGB(247, 126, 192)
fovCircle.Thickness = 1
fovCircle.NumSides = 11
fovCircle.Position = Vector2.new(0, 0)

local isAimbotEnabled = false
local chamsEnabled = false
local rightMouseHeld = false
local isFOVVisible = true
local isVisibilityCheckEnabled = false
local showNames = false
local espEnabled = false
local isFullbrightEnabled = false
local isHitboxExpander = false
local expanderConnection = nil
local isTpWalking = false
local tpwalking = false
local tpwalking_connection = nil
local distanceEnabled = false
local xrayToggledOn = false
local showHealth = false
local showTool = false
local sleepingESPEnabled = false
local stoneOreEnabled = false
local brimstoneOreEnabled = false
local ironOreEnabled = false
local clothEnabled = false
local backpackESPEnabled = false

local smoothness = 1
local aimbotKey = Enum.KeyCode.F

local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'

local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local Window = Library:CreateWindow({
    Title = 'Auralis | Beta Version',
    Center = true, 
    AutoShow = true,
})

local Tabs = {
    Main = Window:AddTab('Main'), 
    ESP = Window:AddTab('ESP'),
    WeaponsTab = Window:AddTab('Weapons'),
    ['World'] = Window:AddTab('World'),
    ['Misc'] = Window:AddTab('Misc'),
    ['UI Settings'] = Window:AddTab('Settings'),
}

local MainLeftBox = Tabs.Main:AddLeftGroupbox('Aimbot')
local MainRightBox = Tabs.Main:AddRightGroupbox('FOV Settings')
local MainCrosshairBox = Tabs.Main:AddRightGroupbox('Crosshair')
local MainHitboxBox = Tabs.Main:AddLeftGroupbox("Hitbox Expander")
local ESPLeftBox = Tabs.ESP:AddLeftGroupbox('ESP Player')
local ESPRightBox = Tabs.ESP:AddRightGroupbox('ESP Resource')
local WeaponsLeftBox = Tabs.WeaponsTab:AddLeftGroupbox("Fast Reload")
local WorldLeftBox = Tabs.World:AddLeftGroupbox('World Settings')
local MiscLeftBox = Tabs.Misc:AddLeftGroupbox('Miscellaneous')
local MovementBox = Tabs.Misc:AddRightGroupbox('Another Miscellaneous')
local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')
local ThirdPersonBox = Tabs.Misc:AddRightGroupbox('Third Person')

local success, Drawing = pcall(function() return Drawing end)
if not success then
    warn("Drawing API not available")
    return
end

local crosshair = {
    horizontal = Drawing.new("Line"),
    vertical = Drawing.new("Line")
}

local function createWorkspaceESP(model)
    local head = model:FindFirstChild("Head", true)
    if not head or not head:IsA("MeshPart") then return end
    
    local esp = {
        text = Drawing.new("Text"),
        highlight = Instance.new("Highlight")
    }
    
    esp.text.Size = 16
    esp.text.Center = true
    esp.text.Outline = true
    esp.text.Visible = false
    esp.text.Color = espColor
    
    esp.highlight.FillColor = espColor
    esp.highlight.OutlineColor = Color3.new(1, 1, 1)
    esp.highlight.FillTransparency = 0.5
    esp.highlight.OutlineTransparency = 0
    esp.highlight.Enabled = false
    esp.highlight.Adornee = head
    esp.highlight.Parent = game:GetService("CoreGui")
    
    workspaceESP[model] = esp
    return esp
end

RunService.RenderStepped:Connect(function()
    if not espEnabled then
        for _, esp in pairs(workspaceESP) do
            esp.text.Visible = false
            esp.highlight.Enabled = false
        end
        return
    end

    local camera = workspace.CurrentCamera
    local localPlayer = Players.LocalPlayer
    local character = localPlayer.Character
    local rootPart = character and character:FindFirstChild("HumanoidRootPart")
    local playersFolder = workspace:FindFirstChild("Players")

    if not rootPart or not playersFolder then return end

    for _, model in pairs(playersFolder:GetChildren()) do
        if model.Name == localPlayer.Name then continue end

        if not workspaceESP[model] then
            workspaceESP[model] = createWorkspaceESP(model)
        end

        local esp = workspaceESP[model]
        local head = model:FindFirstChild("Head", true)

        if esp and head and head:IsA("MeshPart") then
            local pos = head.Position
            local screenPos, onScreen = camera:WorldToViewportPoint(pos)
            local distance = (rootPart.Position - pos).Magnitude

            if distance <= espRenderDistance and onScreen then
                local textLines = {}

                if showNames then
                    table.insert(textLines, model.Name)
                end
                
                if showHealth then
                    local humanoid = model:FindFirstChild("Humanoid")
                    if humanoid then
                        table.insert(textLines, "HP: " .. math.floor(humanoid.Health))
                    end
                end
                
                if distanceEnabled then
                    table.insert(textLines, string.format("[%d studs]", math.floor(distance)))
                end                
            
            local lineCount = #textLines
            local offset = -20 * lineCount
            esp.text.Position = Vector2.new(screenPos.X, screenPos.Y + offset)
            
            esp.text.Text = table.concat(textLines, "\n")
            esp.text.Visible = #textLines > 0            
            esp.highlight.Enabled = chamsEnabled
            else
                esp.text.Visible = false
                esp.highlight.Enabled = false
            end
        end
    end

    for model, esp in pairs(workspaceESP) do
        if not model:IsDescendantOf(playersFolder) then
            if esp.text then esp.text:Remove() end
            if esp.highlight then esp.highlight:Destroy() end
            workspaceESP[model] = nil
        end
    end
end)

local function removeEspBox(player)
    if espBoxes[player] then
        pcall(function()
            espBoxes[player].outline:Remove()
            espBoxes[player].text:Remove()
            espBoxes[player] = nil
        end)
    end
end

local function setupDeathHandler(player)
    if player.Character then
        local humanoid = player.Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.Died:Connect(function()
                removeEspBox(player)
            end)
        end
    end
end

game.Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        setupDeathHandler(player)
    end)
end)

game.Players.PlayerRemoving:Connect(function(player)
    removeEspBox(player)
end)

for _, player in pairs(game.Players:GetPlayers()) do
    if player ~= game.Players.LocalPlayer then
        setupDeathHandler(player)
        player.CharacterAdded:Connect(function(character)
            setupDeathHandler(player)
        end)
    end
end

local function applyChams(player)
    if not player.Character then return end
    if teamCheck and player.Team == game.Players.LocalPlayer.Team then return end
    
    for _, part in pairs(player.Character:GetDescendants()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            if not originalProperties[part] then
                originalProperties[part] = {
                    Material = part.Material,
                    Color = part.Color,
                    Transparency = part.Transparency
                }
            end
            
            part.Material = Enum.Material.ForceField
            part.Color = espColor
            part.Transparency = 0.6
            table.insert(chamsParts, part)
        end
    end
end

RunService.RenderStepped:Connect(function()
    if not chamsEnabled then return end

    local localCharacter = Players.LocalPlayer.Character
    local localRoot = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart")
    if not localRoot then return end

    for _, player in ipairs(Players:GetPlayers()) do
        if player == Players.LocalPlayer then continue end
        local character = player.Character
        if not character or not character:FindFirstChild("HumanoidRootPart") then continue end

        if teamCheck and player.Team == Players.LocalPlayer.Team then continue end

        local distance = (localRoot.Position - character.HumanoidRootPart.Position).Magnitude
        if distance > espRenderDistance then continue end

        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                if not originalProperties[part] then
                    originalProperties[part] = {
                        Material = part.Material,
                        Color = part.Color,
                        Transparency = part.Transparency
                    }
                end

                if not table.find(chamsParts, part) then
                    part.Material = Enum.Material.ForceField
                    part.Color = espColor
                    part.Transparency = 0.6
                    table.insert(chamsParts, part)
                end
            end
        end
    end
end)

local function isExcluded(modelName)
    for _, excludedName in ipairs(excludedModels) do
        if modelName == excludedName then
            return true
        end
    end
    return false
end

local function setTransparency(model, transparency)
    for _, descendant in ipairs(model:GetDescendants()) do
        if descendant:IsA("BasePart") or descendant:IsA("MeshPart") or descendant:IsA("Part") then
            if transparency ~= nil then
                if not originalModelTransparency[descendant] then
                    originalModelTransparency[descendant] = descendant.Transparency
                end
                descendant.Transparency = transparency
            else
                if originalModelTransparency[descendant] then
                    descendant.Transparency = originalModelTransparency[descendant]
                    originalModelTransparency[descendant] = nil
                end
            end
        end
    end
end

local function updateXray()
    if not folder then
        warn("Folder not found in workspace.")
        return
    end

    for _, model in ipairs(folder:GetChildren()) do
        if model:IsA("Model") and not isExcluded(model.Name) then
            if xrayEnabled then
                setTransparency(model, transparencyValue)
            else
                setTransparency(model, nil)
            end
        end
    end
end

local function createResourceESP(model)
    if not model or not model:IsA("Model") then return end

    local part = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
    if not part then return end

    local resourceESPInstance = {
        text = Drawing.new("Text"),
        highlight = Instance.new("Highlight")
    }

    resourceESPInstance.text.Size = 16
    resourceESPInstance.text.Center = true
    resourceESPInstance.text.Outline = true
    resourceESPInstance.text.Visible = false
    resourceESPInstance.text.Color = espColor

    resourceESPInstance.highlight.FillColor = espColor
    resourceESPInstance.highlight.OutlineColor = Color3.new(1, 1, 1)
    resourceESPInstance.highlight.FillTransparency = 0.5
    resourceESPInstance.highlight.OutlineTransparency = 0
    resourceESPInstance.highlight.Enabled = false
    resourceESPInstance.highlight.Adornee = part
    resourceESPInstance.highlight.Parent = game:GetService("CoreGui")

    oreESP[model] = resourceESPInstance
end

local function createSleepingHighlight(model)
    local head = model:FindFirstChild("Head", true)
    if not head or not head:IsA("BasePart") then return end

    local esp = {
        text = Drawing.new("Text"),
        highlight = Instance.new("Highlight")
    }

    esp.text.Size = 16
    esp.text.Center = true
    esp.text.Outline = true
    esp.text.Visible = false
    esp.text.Color = espColor
    esp.text.Text = "Sleeping"

    esp.highlight.FillColor = espColor
    esp.highlight.OutlineColor = Color3.new(1, 1, 1)
    esp.highlight.FillTransparency = 0.5
    esp.highlight.OutlineTransparency = 0
    esp.highlight.Enabled = false
    esp.highlight.Adornee = head
    esp.highlight.Parent = game:GetService("CoreGui")

    sleepingESP[model] = esp
end

local function createBackpackESP(model)
    local part = model:FindFirstChildWhichIsA("BasePart")
    if not part then return end

    local esp = {
        text = Drawing.new("Text"),
        highlight = Instance.new("Highlight")
    }

    esp.text.Size = 16
    esp.text.Center = true
    esp.text.Outline = true
    esp.text.Visible = false
    esp.text.Color = espColor
    esp.text.Text = "Backpack"

    esp.highlight.FillColor = espColor
    esp.highlight.OutlineColor = Color3.new(1, 1, 1)
    esp.highlight.FillTransparency = 0.5
    esp.highlight.OutlineTransparency = 0
    esp.highlight.Enabled = false
    esp.highlight.Adornee = part
    esp.highlight.Parent = game:GetService("CoreGui")

    backpackESP[model] = esp
end

MainLeftBox:AddToggle('AimbotEnabled', {
    Text = 'Enable Aimbot',
    Default = false,
    Tooltip = 'Toggle Aimbot functionality',
    Callback = function(value) isAimbotEnabled = value end
})

MainLeftBox:AddToggle('VisibilityCheck', {
    Text = 'Wall Check',
    Default = false,
    Tooltip = 'Check if target is visible before aiming',
    Callback = function(value) isVisibilityCheckEnabled = value end
})

MainLeftBox:AddDropdown('TargetPartDropdown', {
    Values = { 'Head', 'UpperTorso', 'HumanoidRootPart' },
    Default = 1,
    Multi = false,
    Text = 'Target Part',
    Tooltip = 'Choose which body part to aim at',
    Callback = function(value)
        targetPart = value
        Library:Notify('Now aiming at: ' .. targetPart, 2)
    end
})

MainRightBox:AddSlider('FOVAmount', {
    Text = 'FOV Size',
    Default = 120,
    Min = 20,
    Max = 1000,
    Rounding = 1,
    Compact = false,
    Callback = function(value)
        fovAmount = value
        fovCircle.Radius = value
    end
})

MainRightBox:AddSlider('Smoothness', {
    Text = 'Aim Smoothness',
    Default = 1,
    Min = 0.1,
    Max = 1,
    Rounding = 1,
    Compact = false,
    Callback = function(value) smoothness = value end
})

MainRightBox:AddToggle('ShowFOV', {
    Text = 'Show FOV',
    Default = true,
    Tooltip = 'Toggle FOV circle visibility',
    Callback = function(value)
        isFOVVisible = value
        fovCircle.Visible = value
    end
})

MainRightBox:AddLabel('FOV Color'):AddColorPicker('FOVColor', {
    Default = Color3.fromRGB(247, 126, 192),
    Title = 'FOV Circle Color',
    Callback = function(value)
        fovCircle.Color = value
    end
})

MainHitboxBox:AddToggle('HitboxExpander', {
    Text = 'Hitbox Expander',
    Default = false,
    Tooltip = 'Expands enemy and helicopter hitboxes',
    Callback = function(value)
        isHitboxExpander = value

        if expanderConnection then
            expanderConnection:Disconnect()
            expanderConnection = nil
            for _, player in ipairs(workspace.Players:GetChildren()) do
                if player ~= Players.LocalPlayer.Character then
                    local head = player:FindFirstChild("Head")
                    if head then
                        head.Size = Vector3.new(1, 1, 1)
                        head.Transparency = 0
                    end
                end
            end
            local heli = workspace:FindFirstChild("ActiveRaiderX")
            if heli and heli:FindFirstChild("Base") then
                heli.Base.Size = Vector3.new(1, 1, 1)
                heli.Base.Transparency = 0
            end
        end

        if value then
            expanderConnection = RunService.Heartbeat:Connect(function()
                for _, player in ipairs(workspace.Players:GetChildren()) do
                    if player ~= Players.LocalPlayer.Character then
                        local head = player:FindFirstChild("Head")
                        if head then
                            head.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
                            head.Transparency = hitboxTransparency
                            head.Massless = true
                            head.CanCollide = false
                        end
                    end
                end
                local heli = workspace:FindFirstChild("ActiveRaiderX")
                if heli and heli:FindFirstChild("Base") then
                    heli.Base.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
                    heli.Base.Transparency = hitboxTransparency
                    heli.Base.Massless = true
                    heli.Base.CanCollide = false
                end
            end)
        end
    end
})

MainHitboxBox:AddSlider('HitboxSize', {
    Text = 'Hitbox Size',
    Default = 15,
    Min = 0,
    Max = 50,
    Rounding = 1,
    Compact = false,
    Tooltip = 'Adjust hitbox size',
    Callback = function(value)
        hitboxSize = value
    end
})

MainHitboxBox:AddSlider('HitboxTransparency', {
    Text = 'Hitbox Transparency',
    Default = 0.9,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Compact = false,
    Tooltip = 'Adjust hitbox transparency',
    Callback = function(value)
        hitboxTransparency = value
    end
})

ESPLeftBox:AddToggle('ESP Toggle', {
    Text = 'ESP Toggle',
    Tooltip = 'Turn on or off ESP',
    Callback = function(state)
        espEnabled = state
        if not state then
            for _, esp in pairs(workspaceESP) do
                esp.text.Visible = false
                esp.highlight.Enabled = false
            end
        end
    end
})

ESPLeftBox:AddSlider('RenderDistance', {
    Text = 'ESP Distance',
    Default = 1000,
    Min = 200,
    Max = 2000,
    Rounding = 0,
    Compact = false,
    Tooltip = 'Max distance for Player, Ore, and Cloth ESP',
    Callback = function(value)
        espRenderDistance = value
    end
})

ESPLeftBox:AddLabel('ESP Color'):AddColorPicker('ESP Color', {
    Text = 'ESP Color',
    Tooltip = 'Change ESP color',
    Default = Color3.fromRGB(255, 0, 0),
    Callback = function(color)
        espColor = color
        for _, esp in pairs(workspaceESP) do
            esp.text.Color = color
            esp.highlight.FillColor = color
        end
    end
})

ESPLeftBox:AddToggle('Team Check Esp', {
    Text = 'Team Check Esp',
    Tooltip = 'Toggle team check for visuals',
    Callback = function(state)
        teamCheck = state
    end
})

ESPLeftBox:AddToggle('Chams', { 
    Text = 'Chams',
    Tooltip = 'See players through walls',
    Callback = function(state)
        chamsEnabled = state
        if not state then
            for part, props in pairs(originalProperties) do
                if part and part:IsA("BasePart") then
                    part.Material = props.Material
                    part.Color = props.Color
                    part.Transparency = props.Transparency
                end
            end
            table.clear(chamsParts)
            table.clear(originalProperties)
        end
    end
})

ESPLeftBox:AddToggle('Show Names', {
    Text = 'Show Player Names',
    Tooltip = 'Only works when ESP is also enabled',
    Callback = function(state)
        showNames = state
        if not (espEnabled and showNames) then
            for _, esp in pairs(workspaceESP) do
                if esp.text then
                    esp.text.Visible = false
                end
            end
        end
    end
})

ESPLeftBox:AddToggle('Distance ESP', {
    Text = 'Distance ESP',
    Tooltip = 'Show distance to workspace players', 
    Callback = function(state)
        distanceEnabled = state
        if not state then
            for _, esp in pairs(workspaceESP) do
                esp.text.Visible = false
                esp.highlight.Enabled = false
            end
        end
    end
})

ESPLeftBox:AddToggle('BackpackESP', {
    Text = 'Backpack ESP',
    Default = false,
    Tooltip = 'Show ESP for dropped backpacks',
    Callback = function(state)
        backpackESPEnabled = state
        for _, esp in pairs(backpackESP) do
            esp.text.Visible = espEnabled and state
            esp.highlight.Enabled = espEnabled and state
        end
    end
})

ESPLeftBox:AddToggle('SleepingESP', {
    Text = 'Sleeping ESP',
    Default = false,
    Tooltip = 'Show ESP for sleeping players',
    Callback = function(state)
        sleepingESPEnabled = state
        for _, esp in pairs(sleepingESP) do
            esp.text.Visible = espEnabled and state
            esp.highlight.Enabled = espEnabled and state
        end
    end    
})

ESPRightBox:AddToggle('StoneOreESP', {
    Text = 'Stone Ore ESP',
    Default = false,
    Tooltip = 'Toggle Stone Ore ESP',
    Callback = function(value)
        stoneOreEnabled = value
    end
})

ESPRightBox:AddToggle('BrimstoneOreESP', {
    Text = 'Brimstone Ore ESP',
    Default = false,
    Tooltip = 'Toggle Brimstone Ore ESP',
    Callback = function(value)
        brimstoneOreEnabled = value
    end
})

ESPRightBox:AddToggle('IronOreESP', {
    Text = 'Iron Ore ESP',
    Default = false,
    Tooltip = 'Toggle Iron Ore ESP',
    Callback = function(value)
        ironOreEnabled = value
    end
})

ESPRightBox:AddToggle('ClothESP', {
    Text = 'Cloth ESP',
    Default = false,
    Tooltip = 'Toggle Cloth ESP',
    Callback = function(value)
        clothEnabled = value
    end
})

WorldLeftBox:AddToggle('Fullbright', {
    Text = 'Fullbright',
    Default = false,
    Callback = function(value)
        isFullbrightEnabled = value
        
        if isFullbrightEnabled then
            game.Lighting.Brightness = 2
            game.Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
            game.Lighting.Ambient = Color3.fromRGB(255, 255, 255)
            game.Lighting.GlobalShadows = false
        else
            game.Lighting.Brightness = originalLightingSettings.Brightness
            game.Lighting.OutdoorAmbient = originalLightingSettings.OutdoorAmbient
            game.Lighting.Ambient = originalLightingSettings.Ambient
            game.Lighting.GlobalShadows = originalLightingSettings.GlobalShadows
        end
    end
})

WorldLeftBox:AddToggle('NoFog', {
    Text = 'No Fog',
    Default = false,
    Tooltip = 'Removes fog by pushing it far away',
    Callback = function(enabled)
        if enabled then
            game.Lighting.FogStart = 0
            game.Lighting.FogEnd = 1e10
            Library:Notify('Fog removed', 2)
        else
            game.Lighting.FogStart = originalLightingSettings.FogStart
            game.Lighting.FogEnd = originalLightingSettings.FogEnd
            Library:Notify('Fog restored', 2)
        end
    end
})

MiscLeftBox:AddToggle('XRay', {
    Text = 'XRay',
    Default = false,
    Callback = function(value)
        xrayToggledOn = value
        if not value then
            xrayEnabled = false
            updateXray()
        end
    end
})


MiscLeftBox:AddSlider('XRayTransparency', {
    Text = 'XRay Transparency',
    Default = 0.9,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Compact = false,
    Callback = function(value)
        transparencyValue = value
        if xrayEnabled then updateXray() end
    end
})

MiscLeftBox:AddInput('XRayBind', {
    Default = 'X',
    Numeric = false,
    Text = 'XRay Keybind',
    Tooltip = 'Press a key to bind',
    Placeholder = 'Key',
    Callback = function(value)
        keybindKey = Enum.KeyCode[value:upper()]
    end
})

MovementBox:AddToggle('TPWalk', {
    Text = 'Speedhack',
    Default = false,
    Tooltip = 'Makes you run faster [BLATANT]',
    Callback = function(value)
        isTpWalking = value
        tpwalking = value
        if value then
            local chr = LocalPlayer.Character
            local hum = chr and chr:FindFirstChildWhichIsA("Humanoid")

            if hum then
                local function tpwalk()
                    if tpwalking and chr and hum and hum.Parent then
                        if hum.MoveDirection.Magnitude > 0 then
                            chr:TranslateBy(hum.MoveDirection * TPWalkSpeed / 100)
                        end
                    end
                end

                local tpwalking_connection = RunService.Heartbeat:Connect(function()
                    pcall(function()
                        if not isTpWalking then
                            tpwalking_connection:Disconnect()
                            return
                        end
                        tpwalk()
                    end)
                end)
            end
        end
    end
})

MovementBox:AddSlider('TPWalkSpeed', {
    Text = 'Speedhack Speed',
    Default = 0,
    Min = 0,
    Max = 25,
    Rounding = 0,
    Compact = false,
    Callback = function(value)
        TPWalkSpeed = value
    end
})

MovementBox:AddToggle('NoFallDamage', {
    Text = 'No Fall Damage',
    Default = false,
    Tooltip = 'Prevents taking fall damage',
    Callback = function(state)
        noFallDamageEnabled = state

        if noFallConnection then
            noFallConnection:Disconnect()
            noFallConnection = nil
        end

        if state then
            noFallConnection = RunService.RenderStepped:Connect(function()
                local player = Players.LocalPlayer
                local character = player.Character
                local hrp = character and character:FindFirstChild("HumanoidRootPart")
                local humanoid = character and character:FindFirstChild("Humanoid")
                if not (hrp and humanoid) then return end

                if hrp.Velocity.Y < -50 then
                    local rayOrigin = hrp.Position
                    local rayDirection = Vector3.new(0, -15, 0)
                    local hitPart, hitPos = workspace:FindPartOnRayWithIgnoreList(Ray.new(rayOrigin, rayDirection), {character})
                    if hitPart then
                        local dist = (rayOrigin - hitPos).Magnitude
                        if dist < 15 then
                            local slowFactor = dist / 15
                            local newY = hrp.Velocity.Y * 0.7 * slowFactor
                            hrp.Velocity = Vector3.new(hrp.Velocity.X, math.max(newY, -60), hrp.Velocity.Z)
                        end
                    end
                end
            end)
        end
    end
})

MovementBox:AddToggle('WallClimb', {
    Text = 'Wall Climb',
    Default = false,
    Tooltip = 'Climb walls automatically when walking against them',
    Callback = function(state)
        wallClimbEnabled = state

        if wallClimbConnection then
            wallClimbConnection:Disconnect()
            wallClimbConnection = nil
        end

        if state then
            wallClimbConnection = RunService.RenderStepped:Connect(function()
                local character = Players.LocalPlayer.Character
                local hrp = character and character:FindFirstChild("HumanoidRootPart")
                local humanoid = character and character:FindFirstChild("Humanoid")
                if not (hrp and humanoid) then return end

                local forward = humanoid.MoveDirection
                if forward.Magnitude > 0 then
                    local ray = Ray.new(hrp.Position, forward.Unit * 2)
                    local hitPart, _, normal = workspace:FindPartOnRayWithIgnoreList(ray, {character})
                    if hitPart and math.abs(normal.Y) < 0.1 then
                        hrp.Velocity = Vector3.new(forward.X * 5, 30, forward.Z * 5)
                        humanoid:ChangeState(Enum.HumanoidStateType.Climbing)
                    end
                end
            end)
        end
    end
})

UserInputService.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        rightMouseHeld = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        rightMouseHeld = false
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if input.KeyCode == keybindKey and not gameProcessed then
        if xrayToggledOn then
            xrayEnabled = not xrayEnabled
            updateXray()
            Library:Notify('Xray ' .. (xrayEnabled and "Enabled" or "Disabled"), 2)
        elseif xrayEnabled then
            xrayEnabled = false
            updateXray()
        end
    end
end)    

RunService.RenderStepped:Connect(function()
    if isFOVVisible then
        local mouseLocation = UserInputService:GetMouseLocation()
        fovCircle.Position = Vector2.new(mouseLocation.X, mouseLocation.Y)
    end
end)

local function IsInFov(position)
    local mouse = UserInputService:GetMouseLocation()
    local screenPosition, onScreen = Camera:WorldToViewportPoint(position)
    local distance = (Vector2.new(screenPosition.X, screenPosition.Y) - mouse).Magnitude
    return onScreen and distance <= fovAmount
end

local function IsVisible(targetPart)
    local origin = Camera.CFrame.Position
    local direction = (targetPart.Position - origin).Unit
    local distance = (targetPart.Position - origin).Magnitude

    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    rayParams.FilterDescendantsInstances = {
        game.Players.LocalPlayer.Character,
        targetPart.Parent
    }
    rayParams.IgnoreWater = true

    local result = workspace:Raycast(origin, direction * distance, rayParams)
    return not result or (result.Position - targetPart.Position).Magnitude < 3
end

local function GetClosestPlayer()
    local closest, closestDistance = nil, math.huge
    local mouse = UserInputService:GetMouseLocation()

    local playersFolder = workspace:FindFirstChild("Players")
    if not playersFolder then return nil end

    for _, model in pairs(playersFolder:GetChildren()) do
        if model.Name ~= Players.LocalPlayer.Name then
            local target = model:FindFirstChild(targetPart, true)
            local humanoid = model:FindFirstChild("Humanoid")

            if target and humanoid and humanoid.Health > 0 and IsInFov(target.Position) then
                if teamCheck then
                    local plr = Players:FindFirstChild(model.Name)
                    local localTeam = Players.LocalPlayer.Team
                
                    if plr and localTeam and plr.Team == localTeam then
                        continue
                    end
                end                

                local screenPos, onScreen = Camera:WorldToViewportPoint(target.Position)
                if onScreen then
                    local dist = (Vector2.new(screenPos.X, screenPos.Y) - mouse).Magnitude
                    if dist < closestDistance then
                        if not isVisibilityCheckEnabled or IsVisible(target) then
                            closest = target
                            closestDistance = dist
                        end
                    end
                end
            end
        end
    end

    return closest
end

RunService.RenderStepped:Connect(function()
    if not isAimbotEnabled or not rightMouseHeld then return end

    local target = GetClosestPlayer()
    if target then
        local camPos = Camera.CFrame.Position
        local targetPos = target.Position
        local newCFrame = CFrame.new(camPos, targetPos)

        Camera.CFrame = Camera.CFrame:Lerp(newCFrame, smoothness)
    end
end)

RunService.RenderStepped:Connect(function()
    if not espEnabled then
        for _, esp in pairs(workspaceESP) do
            esp.text.Visible = false
            esp.highlight.Enabled = false
        end
        for _, esp in pairs(oreESP) do
            esp.text.Visible = false
            esp.highlight.Enabled = false
        end
        for _, esp in pairs(sleepingESP) do
            esp.text.Visible = false
            esp.highlight.Enabled = false
        end
        return
    end    

    for _, ore in pairs(resourcesFolder:GetChildren()) do
        if ore:IsA("Model") then

            local showOreESP = false
            if (ore.Name == "Stone Ore" or ore.Name == "Stone Ore Sand") and stoneOreEnabled then
                showOreESP = true
            elseif (ore.Name == "Brimstone Ore" or ore.Name == "Brimstone Ore Sand") and brimstoneOreEnabled then
                showOreESP = true
            elseif (ore.Name == "Iron Ore" or ore.Name == "Iron Ore Sand") and ironOreEnabled then
                showOreESP = true
            end

            if showOreESP then
                if not oreESP[ore] then
                    createResourceESP(ore)
                end

                local oreESPInstance = oreESP[ore]
                local part = ore:FindFirstChildWhichIsA("BasePart")
                if part then
                    local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)

                    if onScreen and (Camera.CFrame.Position - part.Position).Magnitude <= espRenderDistance then
                        oreESPInstance.text.Position = Vector2.new(screenPos.X, screenPos.Y - 20)
                        oreESPInstance.text.Text = ore.Name
                        oreESPInstance.text.Visible = true
                        oreESPInstance.highlight.Enabled = true
                    else
                        oreESPInstance.text.Visible = false
                        oreESPInstance.highlight.Enabled = false
                    end
                end
            else
                if oreESP[ore] then
                    oreESP[ore].text.Visible = false
                    oreESP[ore].highlight.Enabled = false
                end
            end
        end
    end

    if clothFolder and clothEnabled then
        for _, cloth in pairs(clothFolder:GetChildren()) do
            if cloth:IsA("Model") then

                if not oreESP[cloth] then
                    createResourceESP(cloth)
                end

                local clothESP = oreESP[cloth]
                local part = cloth:FindFirstChildWhichIsA("BasePart")
                if part then
                    local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)

                    if onScreen and (Camera.CFrame.Position - part.Position).Magnitude <= espRenderDistance then
                        clothESP.text.Position = Vector2.new(screenPos.X, screenPos.Y - 20)
                        clothESP.text.Text = "Cloth"
                        clothESP.text.Visible = true
                        clothESP.highlight.Enabled = true
                    else
                        clothESP.text.Visible = false
                        clothESP.highlight.Enabled = false
                    end
                end
            else
                if oreESP[cloth] then
                    oreESP[cloth].text.Visible = false
                    oreESP[cloth].highlight.Enabled = false
                end
            end
        end
    else
        for _, cloth in pairs(clothFolder:GetChildren()) do
            if oreESP[cloth] then
                oreESP[cloth].text.Visible = false
                oreESP[cloth].highlight.Enabled = false
            end
        end
    end

    if clothFolder and not clothEnabled then
        for _, cloth in pairs(clothFolder:GetChildren()) do
            if oreESP[cloth] then
                oreESP[cloth].text.Visible = false
                oreESP[cloth].highlight.Enabled = false
            end
        end
    end

    local offlineFolder = workspace:FindFirstChild("OfflinePlayers")
    if offlineFolder then
        for _, model in pairs(offlineFolder:GetChildren()) do
            if not sleepingESP[model] then
                createSleepingHighlight(model)
            end
    
            local esp = sleepingESP[model]
            local head = model:FindFirstChild("Head", true)
    
            if esp and head then
                local screenPos, onScreen = Camera:WorldToViewportPoint(head.Position)
                local distance = (Camera.CFrame.Position - head.Position).Magnitude
    
                if espEnabled and sleepingESPEnabled and onScreen and distance <= espRenderDistance then
                    esp.text.Position = Vector2.new(screenPos.X, screenPos.Y - 20)
                    esp.text.Visible = true
                    esp.highlight.Enabled = true
                else
                    esp.text.Visible = false
                    esp.highlight.Enabled = false
                end
            end
        end
    
        -- Cleanup destroyed
        for model, esp in pairs(sleepingESP) do
            if not model:IsDescendantOf(offlineFolder) then
                if esp.text then esp.text:Remove() end
                if esp.highlight then esp.highlight:Destroy() end
                sleepingESP[model] = nil
            end
        end
    end           
    
    local droppedFolder = workspace:FindFirstChild("DroppedPacks")
    if droppedFolder then
        for _, model in pairs(droppedFolder:GetChildren()) do
            if model:IsA("Model") and model.Name == "Backpack" then
                if not backpackESP[model] then
                    createBackpackESP(model)
                end

                local esp = backpackESP[model]
                local part = model:FindFirstChildWhichIsA("BasePart")

                if esp and part then
                    local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
                    local distance = (Camera.CFrame.Position - part.Position).Magnitude

                    if espEnabled and backpackESPEnabled and onScreen and distance <= espRenderDistance then
                        esp.text.Position = Vector2.new(screenPos.X, screenPos.Y - 20)
                        esp.text.Visible = true
                        esp.highlight.Enabled = true
                    else
                        esp.text.Visible = false
                        esp.highlight.Enabled = false
                    end
                end
            end
        end

        -- Clean up removed backpacks
        for model, esp in pairs(backpackESP) do
            if not model:IsDescendantOf(droppedFolder) then
                if esp.text then esp.text:Remove() end
                if esp.highlight then esp.highlight:Destroy() end
                backpackESP[model] = nil
            end
        end
    end

end)

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings() 
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' }) 
ThemeManager:SetFolder('Auralis')
SaveManager:SetFolder('Auralis/specific-game')
SaveManager:BuildConfigSection(Tabs['UI Settings']) 
ThemeManager:ApplyToTab(Tabs['UI Settings'])
