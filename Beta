
-- Core Variables (General)
local espEnabled = false
local teamCheck = false

-- Visual Variables
local espColor = Color3.fromRGB(255, 0, 0)
local fovColor = Color3.fromRGB(255, 255, 255)
local workspaceESP = {}
local espBoxes = {}
local chamsParts = {}
local originalProperties = {}

-- FOV settings
local fovAmount = 120
local teamCheck = false
local targetPart = "Head"  -- Default target is Head

-- FOV Circle
local fovCircle = Drawing.new("Circle")
fovCircle.Radius = fovAmount
fovCircle.Visible = true
fovCircle.Color = Color3.fromRGB(247, 126, 192)
fovCircle.Thickness = 1
fovCircle.NumSides = 11
fovCircle.Position = Vector2.new(0, 0)

-- Toggle states
local isAimbotEnabled = false
local chamsEnabled = false
local rightMouseHeld = false
local isFOVVisible = true
local isVisibilityCheckEnabled = false


--Aimbot Settings
local smoothness = 1 -- Default smoothness value
local aimbotKey = Enum.KeyCode.F

local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'

local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

-- Services
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

-- Create window
local Window = Library:CreateWindow({
    Title = 'Auralis | Beta Version',
    Center = true, 
    AutoShow = true,
})

-- Create Tabs
local Tabs = {
    Main = Window:AddTab('Main'), 
    ESP = Window:AddTab('ESP'),
    WeaponsTab = Window:AddTab('Weapons'),
    ['World'] = Window:AddTab('World'),
    ['Misc'] = Window:AddTab('Misc'),
    ['UI Settings'] = Window:AddTab('Settings'),
}

-- Main Tab
local MainLeftBox = Tabs.Main:AddLeftGroupbox('Aimbot')
local MainRightBox = Tabs.Main:AddRightGroupbox('FOV Settings')
local MainCrosshairBox = Tabs.Main:AddRightGroupbox('Crosshair')
local MainHitboxBox = Tabs.Main:AddLeftGroupbox("Hitbox Expander")
local ESPLeftBox = Tabs.ESP:AddLeftGroupbox('ESP Settings')
local WeaponsLeftBox = Tabs.WeaponsTab:AddLeftGroupbox("Fast Reload")
local WorldLeftBox = Tabs.World:AddLeftGroupbox('World Settings')
local MiscLeftBox = Tabs.Misc:AddLeftGroupbox('Miscellaneous')
local MovementBox = Tabs.Misc:AddRightGroupbox('Another Miscellaneous')
local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')
local ThirdPersonBox = Tabs.Misc:AddRightGroupbox('Third Person')
local NoclipBox = Tabs.Misc:AddRightGroupbox('Noclip')

-- Initialize Drawing objects after UI
local success, Drawing = pcall(function() return Drawing end)
if not success then
    warn("Drawing API not available")
    return
end

local crosshair = {
    horizontal = Drawing.new("Line"),
    vertical = Drawing.new("Line")
}

-- Update workspace ESP functions
local function createWorkspaceESP(model)
    local head = model:FindFirstChild("Head", true)
    if not head or not head:IsA("MeshPart") then return end
    
    local esp = {
        text = Drawing.new("Text"),
        highlight = Instance.new("Highlight")
    }
    
    esp.text.Size = 16
    esp.text.Center = true
    esp.text.Outline = true
    esp.text.Visible = false
    esp.text.Color = espColor
    
    esp.highlight.FillColor = espColor
    esp.highlight.OutlineColor = Color3.new(1, 1, 1)
    esp.highlight.FillTransparency = 0.5
    esp.highlight.OutlineTransparency = 0
    esp.highlight.Enabled = false
    esp.highlight.Adornee = head
    esp.highlight.Parent = game:GetService("CoreGui")
    
    workspaceESP[model] = esp
    return esp
end

-- Single ESP update loop
game:GetService("RunService").RenderStepped:Connect(function()
    pcall(function()
        if espEnabled then
            local camera = workspace.CurrentCamera
            local localPlayer = game.Players.LocalPlayer
            local character = localPlayer.Character
            local rootPart = character and character:FindFirstChild("HumanoidRootPart")
            local playersFolder = workspace:FindFirstChild("Players")
            
            if not playersFolder then return end
            
            -- Clean up invalid models
            for model, esp in pairs(workspaceESP) do
                if not model:IsDescendantOf(playersFolder) then
                    esp.text:Remove()
                    esp.highlight:Destroy()
                    workspaceESP[model] = nil
                end
            end
            
            -- Update ESP for existing models
            for _, model in pairs(playersFolder:GetChildren()) do
                -- Skip local player's model
                if model.Name == localPlayer.Name then continue end
                
                if not workspaceESP[model] then
                    createWorkspaceESP(model)
                end
                
                local esp = workspaceESP[model]
                if esp and rootPart then
                    local head = model:FindFirstChild("Head", true)
                    if head and head:IsA("MeshPart") then
                        local pos = head.Position
                        local screenPos, onScreen = camera:WorldToViewportPoint(pos)
                        local distance = math.floor((rootPart.Position - pos).Magnitude)
                        
                        if onScreen then
                            esp.text.Position = Vector2.new(screenPos.X, screenPos.Y - 40)
                            esp.text.Text = string.format("%s\n[%d studs]", model.Name, distance)
                            esp.text.Visible = true
                            esp.highlight.Enabled = true
                        else
                            esp.text.Visible = false
                            esp.highlight.Enabled = false
                        end
                    end
                end
            end
        else
            -- Hide all ESP when disabled
            for _, esp in pairs(workspaceESP) do
                esp.text.Visible = false
                esp.highlight.Enabled = false
            end
        end
    end)
end)

-- Add death handling functions
local function removeEspBox(player)
    if espBoxes[player] then
        pcall(function()
            espBoxes[player].outline:Remove()
            espBoxes[player].text:Remove()
            espBoxes[player] = nil
        end)
    end
end

local function setupDeathHandler(player)
    if player.Character then
        local humanoid = player.Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.Died:Connect(function()
                removeEspBox(player)
            end)
        end
    end
end

-- Add character handlers after ESP creation
game.Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        setupDeathHandler(player)
    end)
end)

game.Players.PlayerRemoving:Connect(function(player)
    removeEspBox(player)
end)

-- Setup existing players
for _, player in pairs(game.Players:GetPlayers()) do
    if player ~= game.Players.LocalPlayer then
        setupDeathHandler(player)
        player.CharacterAdded:Connect(function(character)
            setupDeathHandler(player)
        end)
    end
end

-- Add Chams function
local function applyChams(player)
    if not player.Character then return end
    if teamCheck and player.Team == game.Players.LocalPlayer.Team then return end
    
    for _, part in pairs(player.Character:GetDescendants()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            if not originalProperties[part] then
                originalProperties[part] = {
                    Material = part.Material,
                    Color = part.Color,
                    Transparency = part.Transparency
                }
            end
            
            part.Material = Enum.Material.ForceField
            part.Color = espColor
            part.Transparency = 0.6
            table.insert(chamsParts, part)
        end
    end
end

-- Add Chams update loop
game:GetService("RunService").RenderStepped:Connect(function()
    if chamsEnabled then
        for _, player in pairs(game.Players:GetPlayers()) do
            if player ~= game.Players.LocalPlayer then
                applyChams(player)
            end
        end
    end
end)

-- Add cleanup on script end
game:GetService("Players").LocalPlayer.Destroying:Connect(function()
    pcall(function()
        for _, box in pairs(espBoxes) do
            if box.outline then box.outline:Remove() end
            if box.text then box.text:Remove() end
        end
        
        -- Restore original properties for chams
        for part, props in pairs(originalProperties) do
            if part and part:IsA("BasePart") then
                part.Material = props.Material
                part.Color = props.Color
                part.Transparency = props.Transparency
            end
        end

        -- Clean up workspace ESP
        for _, esp in pairs(workspaceESP) do
            esp.text:Remove()
            esp.highlight:Destroy()
        end
        workspaceESP = {}
        
    end)
end)

MainLeftBox:AddToggle('AimbotEnabled', {
    Text = 'Enable Aimbot',
    Default = false,
    Tooltip = 'Toggle Aimbot functionality',
    Callback = function(value) isAimbotEnabled = value end
})

MainLeftBox:AddToggle('VisibilityCheck', {
    Text = 'Wall Check',
    Default = false,
    Tooltip = 'Check if target is visible before aiming',
    Callback = function(value) isVisibilityCheckEnabled = value end
})

MainLeftBox:AddButton('Toggle Target Part', function()
    targetPart = (targetPart == "Head") and "UpperTorso" or "Head"
    Library:Notify('Now aiming at: ' .. targetPart, 2)
end)

MainRightBox:AddSlider('FOVAmount', {
    Text = 'FOV Size',
    Default = 120,
    Min = 20,
    Max = 1000,
    Rounding = 1,
    Compact = false,
    Callback = function(value)
        fovAmount = value
        fovCircle.Radius = value
    end
})

MainRightBox:AddSlider('Smoothness', {
    Text = 'Aim Smoothness',
    Default = 1,
    Min = 0.1,
    Max = 1,
    Rounding = 1,
    Compact = false,
    Callback = function(value) smoothness = value end
})

MainRightBox:AddToggle('ShowFOV', {
    Text = 'Show FOV',
    Default = true,
    Tooltip = 'Toggle FOV circle visibility',
    Callback = function(value)
        isFOVVisible = value
        fovCircle.Visible = value
    end
})

MainRightBox:AddLabel('FOV Color'):AddColorPicker('FOVColor', {
    Default = Color3.fromRGB(247, 126, 192),
    Title = 'FOV Circle Color',
    Callback = function(value)
        fovCircle.Color = value
    end
})

-- Aimbot | FOV | Toggle Part | Stuff Above --

ESPLeftBox:AddToggle('ESP Toggle', {
    Text = 'ESP Toggle',
    Tooltip = 'Turn on or off ESP',
    Callback = function(state)
        espEnabled = state
        if not state then
            for _, esp in pairs(workspaceESP) do
                esp.text.Visible = false
                esp.highlight.Enabled = false
            end
        end
    end
})

ESPLeftBox:AddLabel('ESP Color'):AddColorPicker('ESP Color', {
    Text = 'ESP Color',
    Tooltip = 'Change ESP color',
    Default = Color3.fromRGB(255, 0, 0),
    Callback = function(color)
        espColor = color
        for _, esp in pairs(workspaceESP) do
            esp.text.Color = color
            esp.highlight.FillColor = color
        end
    end
})

ESPLeftBox:AddToggle('Team Check', {
    Text = 'Team Check',
    Tooltip = 'Toggle team check for visuals',
    Callback = function(state)
        teamCheck = state
    end
})

-- Add Chams toggle to Visuals tab
ESPLeftBox:AddToggle('Chams', { 
    Text = 'Chams',
    Tooltip = 'See players through walls',
    Callback = function(state)
        chamsEnabled = state
        if not state then
            for part, props in pairs(originalProperties) do
                if part and part:IsA("BasePart") then
                    part.Material = props.Material
                    part.Color = props.Color
                    part.Transparency = props.Transparency
                end
            end
            table.clear(chamsParts)
            table.clear(originalProperties)
        end
    end
})

ESPLeftBox:AddLabel('Chams Color'):AddColorPicker('Chams Color', {
    Text = 'Chams Color',
    Tooltip = 'Change chams color',
    Default = Color3.fromRGB(255, 0, 0),
    Callback = function(color)
        for _, part in pairs(chamsParts) do
            if part and part:IsA("BasePart") then
                part.Color = color
            end
        end
    end
})

-- Add workspace ESP toggle
ESPLeftBox:AddToggle('Distance ESP', {
    Text = 'Distance ESP',
    Tooltip = 'Show distance to workspace players', 
    Callback = function(state)
        distanceEnabled = state
        if not state then
            for _, esp in pairs(workspaceESP) do
                esp.text.Visible = false
                esp.highlight.Enabled = false
            end
        end
    end
})

UserInputService.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        rightMouseHeld = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        rightMouseHeld = false
    end
end)

RunService.RenderStepped:Connect(function()
    if isFOVVisible then
        local mouseLocation = UserInputService:GetMouseLocation()
        fovCircle.Position = Vector2.new(mouseLocation.X, mouseLocation.Y)
    end
end)

local function IsInFov(position)
    local mouse = UserInputService:GetMouseLocation()
    local screenPosition, onScreen = Camera:WorldToViewportPoint(position)
    local distance = (Vector2.new(screenPosition.X, screenPosition.Y) - mouse).Magnitude
    return onScreen and distance <= fovAmount
end

local function IsVisible(targetPart)
    local origin = Camera.CFrame.Position
    local direction = (targetPart.Position - origin).Unit
    local distance = (targetPart.Position - origin).Magnitude

    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    rayParams.FilterDescendantsInstances = {
        game.Players.LocalPlayer.Character,
        targetPart.Parent
    }
    rayParams.IgnoreWater = true

    local result = workspace:Raycast(origin, direction * distance, rayParams)
    return not result or (result.Position - targetPart.Position).Magnitude < 3
end

local function GetClosestPlayer()
    local closest, closestDistance = nil, math.huge
    local mouse = UserInputService:GetMouseLocation()

    local playersFolder = workspace:FindFirstChild("Players")
    if not playersFolder then return nil end

    for _, model in pairs(playersFolder:GetChildren()) do
        if model.Name ~= Players.LocalPlayer.Name then
            local target = model:FindFirstChild(targetPart, true)
            local humanoid = model:FindFirstChild("Humanoid")

            if target and humanoid and humanoid.Health > 0 and IsInFov(target.Position) then
                if teamCheck then
                    local plr = Players:FindFirstChild(model.Name)
                    if plr and plr.Team == Players.LocalPlayer.Team then
                        continue
                    end
                end

                local screenPos, onScreen = Camera:WorldToViewportPoint(target.Position)
                if onScreen then
                    local dist = (Vector2.new(screenPos.X, screenPos.Y) - mouse).Magnitude
                    if dist < closestDistance then
                        if not isVisibilityCheckEnabled or IsVisible(target) then
                            closest = target
                            closestDistance = dist
                        end
                    end
                end
            end
        end
    end

    return closest
end

RunService.RenderStepped:Connect(function()
    -- Early exit unless both aimbot is toggled AND right-click is held
    if not isAimbotEnabled or not rightMouseHeld then return end

    local target = GetClosestPlayer()
    if target then
        local camPos = Camera.CFrame.Position
        local targetPos = target.Position
        local newCFrame = CFrame.new(camPos, targetPos)

        Camera.CFrame = Camera.CFrame:Lerp(newCFrame, smoothness)
    end
end)

